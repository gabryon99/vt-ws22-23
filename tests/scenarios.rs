use std::{
    i32,
    os::raw::{c_char, c_int}
};

use vt_vm::vm::{self, program::Program};

// Add binding for `init` function contained inside `tests/gen.c`.
extern "C" {
    pub fn init(
        buf: *mut c_char,
        size: c_int,
        prob: *mut c_int,
        seed: c_int,
        r_a: *mut c_int,
        r_l: *mut c_int,
    );
}

#[derive(Debug, serde::Serialize)]
struct Stats {
    running_mode: vm::RunningMode,
    scenario: usize,
    min: u128,
    max: u128,
    average: f64,
    iterations: u32
}

/// Returns a pseudo-random scenario generated by the given C program.
fn generate_scenario(size: usize, seed: i32, mut probs: [i32; 5]) -> vm::program::Program {
    let mut r_a: i32 = 0;
    let mut r_l: i32 = 0;

    let mut data: Vec<u8> = Vec::new();
    data.resize(size, 0);

    unsafe {
        init(
            data.as_mut_ptr() as *mut i8,
            size as i32,
            probs.as_mut_ptr(),
            seed,
            &mut r_a,
            &mut r_l,
        )
    }

    Program::new(data, r_a, r_l)
}

#[test]
pub fn scenario_1() {
    let prog = generate_scenario(10_000, 1, [0, 1, 0, 0, 0]);
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn scenario_2() {
    let prog = generate_scenario(10_000, 1, [1, 1, 1, 0, 0]);
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn scenario_3() {
    let prog = generate_scenario(10_000, 1, [1, 9, 1, 5, 5]);
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn scenario_4() {
    let prog = generate_scenario(50_000, 1, [1, 9, 1, 5, 5]);
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn scenario_custom_0() {
    let prog = Program { 
        data: vec![2, 2, 2, 2, 2, 2, 5, 5, 0], 
        initial_acc: 10,
        initial_lc: 0, 
        filename: None 
    };
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn scenario_custom_1() {
    let prog = Program { 
        data: vec![4, 2, 2, 2, 2, 2, 2, 2, 5, 5, 0], 
        initial_acc: 0,
        initial_lc: 2, 
        filename: None 
    };
    let vm = vm::VM::new(vm::RunningMode::Simple, prog);
    vm.run();
    println!("{}", vm);
}

#[test]
pub fn bench() {

    let modes = [vm::RunningMode::Simple, vm::RunningMode::NoOptJitted, vm::RunningMode::OptJitted];
    let scenarios = [
        generate_scenario(10_000, 1, [0, 1, 0, 0, 0]),
        generate_scenario(10_000, 1, [1, 1, 1, 0, 0]),
        generate_scenario(10_000, 1, [1, 9, 1, 5, 5]),
        generate_scenario(50_000, 1, [1, 9, 1, 5, 5])
    ];

    let mut stats: Vec<Stats> = vec![];
    let iterations = 32;

    for mode in &modes {
        println!("[info] :: running scenarios with mode '{:?}'", mode);
        for scenario_index in 0..scenarios.len() {
            
            let mut running_times = vec![];
            for _ in 0..iterations {
                let vm = vm::VM::new(mode.clone(), scenarios[scenario_index].clone());
                vm.run();
                running_times.push(vm.running_time.get().as_nanos());
            }

            let min = running_times.clone().into_iter().min().unwrap();
            let max = running_times.clone().into_iter().max().unwrap();

            let average = (running_times.into_iter().sum::<u128>() as f64) / (iterations as f64);

            stats.push(Stats {
                running_mode: mode.clone(),
                scenario: (scenario_index + 1),
                min: min,
                max: max,
                average,
                iterations
            })

        }
    }

    let mut wtr = csv::Writer::from_writer(std::io::stdout());
    for stat in stats {
        wtr.serialize(stat).unwrap();
    }

    wtr.flush().unwrap();

}
